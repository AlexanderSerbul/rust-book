[[questions]]
type = "MultipleChoice"
prompt.prompt = """
Given a function `sleep(d)` that sleeps for the given duration, consider this function:

```rust
let futs: Vec<_> = [1, 2, 3].iter().map(|n| async {
  sleep(Duration::from_secs(5)).await;
  n + 1
}).collect();

for fut in futs {
  let n = fut.await;
  println!("{n}");
}
```

When executed, about how many seconds should this take to execute?
"""
prompt.distractors = ["5", "0"]
answer.answer = "15"
context = """
Without using a function like `join_all`, the futures will not run concurrently. Therefore this code would take 15 seconds (5 seconds per list element).
"""
id = "68680e2e-7a9f-4cee-8080-70e57fe5a2b3"

[[questions]]
type = "MultipleChoice"
prompt.prompt = """
Imagine Rust did not require that futures were pinned in order to be polled. 
Which of the following async functions could potentially cause undefined behavior if not pinned?
"""
prompt.distractors = [
"""
```rust
async fn example(x: &i32) -> i32 {
    sleep(Duration::from_secs(1)).await;
    *y
}
```
""",
"""
```rust
async fn example(x: Vec<i32>) -> i32 {
    sleep(Duration::from_secs(1)).await;
    x[0]
}
```
""",
"""
```rust
async fn example() -> i32 {
    let x = 0;
    sleep(Duration::from_secs(1)).await;
    x
}
```
""",  
]
answer.answer = """
```rust
async fn example(x: i32) -> i32 {
    let y = &x;
    sleep(Duration::from_secs(1)).await;
    *y
}
```
"""
context = """
The core problem addressed by pinning in self-reference, or a future which contains a pointer to itself. 
This happens an async block contains a local variable that refers to another local variable in the future.
Here, that would be `y = &x`.
"""
id = "bc8b4acb-d111-4fec-b89a-e5d1bc77c8f2"