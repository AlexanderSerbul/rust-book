[[questions]]
id = "652e596c-7cc9-42e6-a7f8-701879cd9a2b"
type = "MultipleChoice"
prompt.prompt = """
Consider this unsafe program:
```aquascope,interpreter,shouldFail
#fn main() {
let v1 = vec![1, 2, 3];
let mut v2 = v1;
v2.push(4);
println!("{}", v1[0]);`[]`    
#}
```

Which of the following best describes how undefined behavior occurs in this program?
"""
answer.answer = "`v1[0]` reads `v1`, which points to deallocated memory"
prompt.distractors = [
  "`v2` owns the vector data on the heap, while `v1` does not",
  "`v1` has been moved into `v2` on line 2",
  "`v1` has its pointer invalidated by the `push` on line 3"
]
context = """
The undefined behavior arises because `v1` is read after being freed. Note that the other three options are correct statements
about the program, but they do not explain why the undefined behavior actually occurs. For example, if the `println` were deleted,
then the other three options are still true, but the program no longer has undefined behavior.
"""

[[questions]]
id = "94425a4e-043e-47f8-9fba-c5b09fb60aa3"
type = "Tracing"
prompt.program = """
fn add_suffix(mut s: String) -> String {
  s.push_str(" world");
  s
}

fn main() {
  let s = String::from("hello");
  let s2 = add_suffix(s);
  println!("{}", s2);
}
"""
answer.doesCompile = true
answer.stdout = "hello world"
context = """
This program is valid because `s` is not used after moving it into `add_suffix`.
"""

[[questions]]
id = "c00e3638-861b-4f9e-a55c-bfb67af79280"
type = "Tracing"
prompt.program = """
fn main() {
  let s = String::from("hello");
  let s2;
  let b = false;
  if b {
    s2 = s;
  }
  println!("{}", s);
}
"""
answer.doesCompile = false
answer.lineNumber = 8
context = """
Because `s` could be moved inside of the if-statement, it is illegal to use it on line 8.
"""

[[questions]]
id = "f7d67c11-60bb-4d92-8cc2-8ce82cf4c974"
type = "MultipleChoice"
prompt.prompt = """
Say we have a function that moves a box, like this:
```
fn move_a_box(b: Box<i32>) {
  // This space intentionally left blank
}
```

Below are four snippets which are rejected by the Rust compiler. 
Imagine that Rust instead allowed these snippets to compile and run. 
Select each snippet that would cause undefined behavior.
"""
answer.answer = [
"""
```
let b = Box::new(0);
let b2 = b;
move_a_box(b);
```
""",
"""
```
let b = Box::new(0);
move_a_box(b);
println!("{}", b);
```
""",
"""
```
let b = Box::new(0);
move_a_box(b);
let b2 = b;
```
"""
]
prompt.distractors = [
"""
```
let b = Box::new(0);
let b2 = b;
println!("{}", b);
move_a_box(b2);
```
""",
]
context = """
The key idea is that when a box is passed to `move_a_box`, its memory is deallocated after `move_a_box` ends.
Therefore:
* Reading `b` via `println` after `move_a_box` is undefined behavior, as it reads freed memory.
* Giving `b` a second owner is undefined behavior, as it would cause Rust to free the box a second time on behalf of `b2`. It doesn't matter whether the `let b2 = b` binding happens
  before or after `move_a_box`.

However, doing `let b2 = b` and then `println` is not undefined behavior. Although `b` is moved, its data is not deallocated until `move_a_box` is called at the end. Therefore 
this program is technically safe, although still rejected by Rust.
"""